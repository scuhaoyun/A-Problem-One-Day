###1.二叉树相关定义：
1. 节点的度。节点所拥有的子树的个数。
2. 叶节点。度为0的节点。
3. 分支节点。度不为0的节点。
4. 左孩子，右孩子，双亲。树中一个结点的子树的根节点称为这个结点的孩子。这个结点称为他孩子结点的双亲。具有同一个双亲的孩子结点互称为兄弟。
5. 路径，路径长度。路径长度等于路径中结点个数-1.
6. 祖先，子孙。
7. 结点的层数。树的根节点层数为1，其余结点的层数等于他的双亲结点的层数加1。
8. 树的深度。树中所有结点的最大层数。
9. 树的度。树中各结点度的最大值。
10. 满二叉树。所有分支结点都存在左子树和右子树，且叶子结点都在同一层上。即是节点数=2^n - 1。
11. 完全二叉树。对应满二叉树，叶子结点只能出现在最下层或次下层，且最下层的叶子结点集中在树的左部。

###2.二叉树的性质：
1. 一棵非空二叉树的第i层上最多有2^(i-1)个结点(i>=1)。
2. 一棵深度为k的二叉树中，最多具有2^k-1个结点，最少有k个结点。
3. 一棵非空二叉树的度为0的结点个数总是比度为2的结点个数多1。n0=n2+1。(通过结点和边的关系证明)。
4. 具有n个结点的完全二叉树的深度为log2(n)+1。 log2(n)向下取整。

###3.霍夫曼编码。
霍夫曼是一种非等长编码，其既不会引起歧义，又可以解码出正确的数据，并且出现概率大的数据编码短，概率小的数据编码长，极大地提高了编码效率。
编码过程：

###4.B树？
即二叉搜索树(所有非叶子结点至多拥有两个儿子（Left和Right）；所有结点存储一个关键字；非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；)。如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；
[参考](http://blog.csdn.net/quitepig/article/details/8041308)

###5.B-树？
#####是一种多路搜索树（并不是二叉的）：
1. 定义任意非叶子结点最多只有M个儿子；且M>2；
2. 根结点的儿子数为[2, M]；
3. 除根结点以外的非叶子结点的儿子数为[M/2, M]；
4. 每个结点存放至少M/2-1（取上整. 和至多M-1个关键字；（至少2个关键字）
5. 非叶子结点的关键字个数=指向儿子的指针个数-1；
6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
7. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
8. 所有叶子结点位于同一层；
B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；


#####B-树的特性：
1. 关键字集合分布在整颗树中；
2. 任何一个关键字出现且只出现在一个结点中；
3. 搜索有可能在非叶子结点结束；
4. 其搜索性能等价于在关键字全集内做一次二分查找；
5. 自动层次控制；
由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为O（logn）

###6.B+树？
#####B+树是B-树的变体，也是一种多路搜索树，其定义基本与B-树同，除了：
1. 非叶子结点的子树指针与关键字个数相同；
2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
3. 为所有叶子结点增加一个链指针；
4. 所有关键字都在叶子结点出现；
B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全
集做一次二分查找；


####B+的特性：
1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
2. 不可能在非叶子结点命中；
3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字. 数据的数据层)；
4. 更适合文件索引系统；

###7.B\*树？
- 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；
 B\*树定义了非叶子结点关键字个数至少为(2/3)\*M，即块的最低使用率为2/3（代替B+树的1/2）；
- B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，
所以它不需要指向兄弟的指针；
- B\*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字
范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
- 所以，B*树分配新结点的概率比B+树要低，空间使用率更高；

###8.红黑树?
> 红黑树（Red-Black Tree）是二叉搜索树（Binary Search Tree）的一种改进。我们知道二叉搜索树在最坏的情况下可能会变成一个链表（当所有节点按从小到大的顺序依次插入后）。
而红黑树在每一次插入或删除节点之后都会花O（log N）的时间来对树的结构作修改，以保持树的平衡。也就是说，红黑树的查找方法与二叉搜索树完全一样；插入和删除节点的的方法前半部分
节与二叉搜索树完全一样，而后半部分添加了一些修改树的结构的操作。


红黑树的每个节点上的属性除了有一个key、3个指针：parent、lchild、rchild以外，还多了一个属性：color。它只能是两种颜色：红或黑。而红黑树除了具有二叉搜索树的所有性质之外，还具有以下4点性质：
1. 根节点是黑色的。
2. 空节点是黑色的（红黑树中，根节点的parent以及所有叶节点lchild、rchild都不指向NULL，而是指向一个定义好的空节点）。
3. 红色节点的父、左子、右子节点都是黑色。
4. 在任何一棵子树中，每一条从根节点向下走到空节点的路径上包含的黑色节点数量都相同。