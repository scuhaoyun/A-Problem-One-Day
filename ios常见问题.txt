1.IOS对象间的通信方式有哪些？
 对象之间通信方式主要有：直接方法调用，Target-Action,Delegate,回调(block,closure),KVO,通知

2.iOS中有哪些数据持久化的方式，各有什么优点，iOS平台怎么做数据的持久化？CoreData和sqlite有无必然联系？CoreData是一个关系型数据库吗?
（1）主要由四种持久化方式：属性列表、对象归档、SQLite数据库、CoreData
（2）CoreData不是一个数据库，不过可以使用Sqlite数据库来保持数据，也可以使用其他的方式来存储数据，例如：xml
（3）属性列表、对象归档适合小数据量存储和查询操作
（4）Sqlite、CoreData适合大数据量存储和查询操作

3.UITableviewCell高度计算的优化？
（1）对于所有Cell高度固定的UITableView，使用self.tableview.rowHeight = xxx 而不是通过delegate的方式来设置(避免多次调用委托方法)。
（2）使用self.tableView.estimatedRowHeight = xxx ，使得Cell负责自身高度的计算。
（3）参考http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/

4.UITableview优化?
  性能瓶颈一般来源于Cell高度的计算和Cell的绘制。
  具体针对性优化(针对复杂的UITableView):
（1）提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法。
（2）异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口。
（3）滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！（SDWebImage已经实现异步加载，配合这条性能杠杠的）。
   一般优化思路；
（1）正确使用reuseIdentifier来重用Cells。
（2）对UITableViewCell高度计算优化。
（3）尽量使所有的view opaque，包括cell。尽量少用或不用透明图层。
（4）如果Cell的内容来自Web，使用异步加载，并缓存结果.
（5）减少subviews的数目。
（6）尽量少用addView给Cell动态添加View，可以初始化时就添加，通过hide来控制显示。
（7）在heightForRowAtIndexPath；中尽量不使用cellForRowAtIndexPath:，如果需要用到，只用一次后缓存结果。
（8）手动用代码创建Cell代替用Xib和Stroryboard创建(需要系统转码，增加系统负担[不确定能优化多少])>
  参考：http://www.cocoachina.com/ios/20150602/11968.html

5.UIView和CALayer的区别？
（1）UIView是iOS系统中界面元素的基础，用来管理界面元素，继承UIkit,可以响应事件。而CALayer则是用来绘制界面元素的，它继承自NSObject，不能响应事件。
（2）UIView的绘制由CALayer负责。UIView主要侧重于对显示元素的管理，而CALayer主要侧重于对显示元素的绘制。
（3）UIView的layer树形在系统内部，被系统维护着三份copy（这段理解有点吃不准）。
   第一份，逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份。
   第二份，动画树，这是一个中间层，系统正在这一层上更改属性，进行各种渲染操作。
   第三份，显示树，这棵树的内容是当前正被显示在屏幕上的内容。
   这三棵树的逻辑结构都是一样的，区别只有各自的属性。
（4）CALayer的坐标系系统和UIView有点不一样，它多了一个叫anchorPoint的属性。
  参考内容：
  http://www.cocoachina.com/ios/20150828/13244.html
  http://www.cnblogs.com/pengyingh/articles/2381673.html

6.UIView的layoutsubviews的调用时机？
（1）当view的bounds发生改变时。
（2）当view的直接subView的bounds发生改变时。
（3）当subView添加或移除时。
（4）调用setNeedsLayout方法会在下一个显示周期主动调用layoutsubviews。

7.什么是RunLoop?RunLoop和多线程的关系？
（1）RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行 Event Loop的逻辑。线程执行了这个函数后，
就会一直处于这个函数内部 "接受消息->等待->处理" 的循环中，直到这个循环结束（比如传入quit的消息），函数返回。 ﻿
（2）runloop是运动循环,不断跑圈,无限循环。Runloop的功能就像他的名字听起来一样，使线程进入一个循环，当事件到达的时候调用事件处理方法。我们
要自己提供实现Runloop实际循环运行的控制语句，话句话说就是我们要提供while或者for来驱动Runloop。在循环内部我们运行Runloop，当事件到达的时
候调用事件处理器。
（3）作用:
   ﻿保持程序的持续运行 (iOS程序一直活着的原因)
   ﻿处理App中的各种事件(eg:触摸事件/定时器事件/selector事件【选择器·performSelector···】)
   节省CPU资源,提高程序的性能(有事做事,没事休息)
   程序已启动,就开启了一个runloop无限循环,因此程序才能持续的运行
   在Cocoa中，每个线程(NSThread)对象中内部都有一个run loop（NSRunLoop）对象用来循环处理输入事件，处理的事件包括两类，一是来自
Input sources的异步事件，一是来自Timer sources的同步事件;run Loop在处理输入事件时会产生通知，可以通过Core Foundation向线程中添加
run-loop observers来监听特定事件,以在监听的事件发生时做附加的处理工作。
（4）Runloop与线程的关系
  线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。
RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。
（5）Runloop相关的类
  CFRunloopRef
  CFRunloopModeRef【Runloop的运行模式】
  CFRunloopSourceRef【Runloop要处理的事件源】
  CFRunloopTimerRef【Timer事件】
  CFRunloopObserverRef【Runloop的观察者（监听者）】
  一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这
个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，
让其互不影响。Runloop要想跑起来,它的内部必须要有一个mode,mode中必须有source/observer/time,至少要有其中的一个。
  参考：http://blog.ibireme.com/2015/05/18/runloop/  http://www.cocoachina.com/ios/20160612/16631.html

8.MRC和ARC对比?
MRC 的计数器机制改善了内存管理的方式，减少了各个模块的逻辑耦合，释放了程序员对“何时该释放”的心理压力，解决了大部分的问题。
ARC 的初衷是为了让程序员写代码的时候更加便利，最好不用再关注任何内存释放的问题（也不用关注用什么方式初始化的问题）,系统在运行时统一管理所有内存对象
的释放，会导致增加额外的内存和 CPU 开销，在硬件设备尚且处于低级阶段的时候，当程序员们依然在努力降低内存降低 CPU 消耗的时候，推出这样的机制，是不合
时宜的！

9.什么情况下用weak关键字？
（1）在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决，比如delegate。
（2）自身已经对它进行一次强引用，没有必要再强引用一次，此时也使用weak，自定义IBOutlet连出来的控件属性一般也使用weak，当然他也可以用Strong[原因：
使用storyboard创建的viewController，那么会有一个叫 _topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，
同时top level对象强引用所有子对象，那么vc没必要再强引用top level对象的子对象，IBOutlet的属性一般可以设为weak是因为它已经被view引用了，除非
view被释放，否则IBOutlet的属性也不会被释放，另外IBOutlet属性的生命周期和view应该是一致的，所以IBOutlet属性一般设为weak]。

10. BAD_ACCESS在什么情况下出现？ 
 访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。死循环

11.weak和unowned的区别和联系?
(1)几时用weak,几时用unowned呢？
   举Notification的例子来说,如果Self在闭包被调用的时候有可能是Nil,则使用weak.如果Self在闭包被调用的时候永远不会是Nil，则使用unowned。
(2)使用unowned有什么坏处呢？
   如果我们没有确定好Self在闭包里调用的时候不会是Nil就使用了unowned。当闭包调用的时候,访问到声明为unowned的Self时。程序就会奔溃。这类似于访问
   了悬挂指针（进一步了解，请阅读Crash in Cocoa）。对于熟悉Objective-C的大家来说,unowned在这里就类似于OC的unsafe_unretained。在对象被清
   除后,声明为weak的对象会置为nil,而声明为unowned的对象则不会。
(3)那么既然unowned可能会导致崩溃,为什么我们不全部都用weak来声明呢？
   原因是使用unowned声明,我们能直接访问。而用weak声明的,我们需要unwarp后才能使用。并且直接访问在速度上也更快。（这位国外的猿说:Unowned is 
   faster and allows for immutability and nonoptionality. If you don't need weak, don't use it.），其实说到底,unowned的引入
   是因为Swift的Optional机制。因此我们可以根据实际情况来选择使用weak还是unowned。个人建议,如果无法确定声明对象在闭包调用的时候永远不会是nil,还
   是使用weak来声明。安全更重要。

12.Swift和Objective-C对比?
（1）我认为类型的安全性是 Swift 一个很大的优势，相对OC来说，某些检测从运行时转移到编译时。
（2）Swift 另外一个很棒的功能是内置的不可变性。
（3）Swift中使用结构体和其他的值类型大幅提高代码的清晰度、灵活性和可读性的。值类型的优势:值类型是稳定的,值类型是孤立的,值类型是可交换的。

13.GCD是什么？
（1）为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。
（2）通过 GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加代码块即可，GCD 在后端管理着一个线程池。GCD 不仅决定着你的代码块将在哪个线程被执行，
    它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。
（3）GCD 带来的另一个重要改变是，作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。
（4）GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以
    创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。使用不同优先级的若干
    个队列乍听起来非常直接，不过，我们强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调
    度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。
（5）虽然 GCD 是一个低层级的 C API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱。

14.什么是响应链？
在我们点击屏幕的时候，iphone OS获取到了用户进行了“单击”这一行为，操作系统把包含这些点击事件的信息包装成UITouch和UIEvent形式的实例，然后找到当前运行的程序，
逐级寻找能够响应这个事件的对象，直到没有响应者响应。这一寻找的过程，被称作事件的响应链，不同的响应者以链式的方式寻找。
响应查找的顺序是： UIStatusBar相关的视图-> UIWindow -> UIView -> AView -> DView -> BView（系统在事件链传递的过程中一定会遍历所有的子视图判断是否
能够响应点击事件）。可以推测出UIApplication对象维护着自己的一个响应者栈，当pointInSide: withEvent:返回yes的时候，响应者入栈。栈顶的响应者作为最优先处
理事件的对象，假设AView不处理事件，那么出栈，移交给UIView，以此下去，直到事件得到了处理或者到达AppDelegate后依旧未响应，事件被摒弃为止。通过这个机制我们也
可以看到controller是响应者栈中的例外，即便没有pointInSide: withEvent:的方法返回可响应，controller依旧能够入栈成为UIView的下一个响应者。
参考:http://www.cocoachina.com/ios/20160113/14896.html
