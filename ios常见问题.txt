1.IOS对象间的通信方式有哪些？
 对象之间通信方式主要有：直接方法调用，Target-Action,Delegate,回调(block,closure),KVO,通知

2.iOS中有哪些数据持久化的方式，各有什么优点，iOS平台怎么做数据的持久化？CoreData和sqlite有无必然联系？
 CoreData是一个关系型数据库吗?
（1）主要由四种持久化方式：属性列表、对象归档、SQLite数据库、CoreData
（2）CoreData不是一个数据库，不过可以使用Sqlite数据库来保持数据，也可以使用其他的方式来存储数据，例如：xml
（3）属性列表、对象归档适合小数据量存储和查询操作
（4）Sqlite、CoreData适合大数据量存储和查询操作

3.UITableviewCell高度计算的优化？
（1）对于所有Cell高度固定的UITableView，使用self.tableview.rowHeight = xxx 而不是通过delegate的方式
    来设置(避免多次调用委托方法)。
（2）使用self.tableView.estimatedRowHeight = xxx ，使得Cell负责自身高度的计算。
（3）参考http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/

4.UITableview优化?
  性能瓶颈一般来源于Cell高度的计算和Cell的绘制。
  具体针对性优化(针对复杂的UITableView):
（1）提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法。
（2）异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口。
（3）滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！（SDWebImage已经实现异步加载，配合这条性能杠杠的）。
   一般优化思路；
（1）正确使用reuseIdentifier来重用Cells。
（2）对UITableViewCell高度计算优化。
（3）尽量使所有的view opaque，包括cell。尽量少用或不用透明图层。
（4）如果Cell的内容来自Web，使用异步加载，并缓存结果.
（5）减少subviews的数目。
（6）尽量少用addView给Cell动态添加View，可以初始化时就添加，通过hide来控制显示。
（7）在heightForRowAtIndexPath；中尽量不使用cellForRowAtIndexPath:，如果需要用到，只用一次后缓存结果。
（8）手动用代码创建Cell代替用Xib和Stroryboard创建(需要系统转码，增加系统负担[不确定能优化多少])>
  参考：http://www.cocoachina.com/ios/20150602/11968.html

5.UIView和CALayer的区别？
（1）UIView是iOS系统中界面元素的基础，用来管理界面元素，继承UIkit,可以响应事件。而CALayer则是用来绘制界面元
    素的，它继承自NSObject，不能响应事件。
（2）UIView的绘制由CALayer负责。UIView主要侧重于对显示元素的管理，而CALayer主要侧重于对显示元素的绘制。
（3）UIView的layer树形在系统内部，被系统维护着三份copy（这段理解有点吃不准）。
   第一份，逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份。
   第二份，动画树，这是一个中间层，系统正在这一层上更改属性，进行各种渲染操作。
   第三份，显示树，这棵树的内容是当前正被显示在屏幕上的内容。
   这三棵树的逻辑结构都是一样的，区别只有各自的属性。
（4）CALayer的坐标系系统和UIView有点不一样，它多了一个叫anchorPoint的属性。
  参考内容：
  http://www.cocoachina.com/ios/20150828/13244.html
  http://www.cnblogs.com/pengyingh/articles/2381673.html

